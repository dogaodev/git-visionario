/**
 * @fileoverview Entry point for the requester module.
 *
 * This file imports the main engine from the services directory and exports it as the default export.
 * Additionally, it re-exports all types from the helpers/types module.
 *
 * @module requester
 */
import NyroClass, { RequestInfo, RequestOptions as OptionsInterface, HttpResponse as ResponseInterface, Headers as HeadersInterface, InferBodySchema, BodyFromSchema, Events, QueueOptions, PaginationOptions, AuthOptions, ProxyOptions } from './services/engine';
import Headers from './services/headersConstructor';
import Options from './services/optionsConstructor';
import NyroError, { isNyroError, NyroErrorInterface, NyroErrorResponse } from './helpers/errorHandler';
import Proxy, { Protocol, ProxyAPIOptions, ProxyAPIResponse, ProxyObject, ProxyFetchOptions, ProxyFormat, ProxyFilterOptions, OmitedProxyAPIResponse, Anonymity, Country, Format } from './services/proxyManager';
import UserAgent, { AndroidVersions, ChromeVersions, SafariVersions, UserAgentBrowser, UserAgentDevice, UserAgentOS, GenerateUserAgentOptions, generateAndroid, generateChrome, generateEdge, generateFirefox, generateSafari, getRandomVersion } from './services/userAgentConstuctor';
import PluginManager, { Plugin as PluginInterface } from './services/pluginManager';
declare var Nyro: NyroClass;
declare const version: string;
declare const get: <T, B>(url?: string, options?: OptionsInterface<B>) => Promise<ResponseInterface<T, BodyFromSchema<B, OptionsInterface>>>, patch: <T, B>(url?: string, options?: OptionsInterface<B>) => Promise<ResponseInterface<T, BodyFromSchema<B, OptionsInterface>>>, post: <T, B>(url?: string, options?: OptionsInterface<B>) => Promise<ResponseInterface<T, BodyFromSchema<B, OptionsInterface>>>, put: <T, B>(url?: string, options?: OptionsInterface<B>) => Promise<ResponseInterface<T, BodyFromSchema<B, OptionsInterface>>>, _delete: <T, B>(url?: string, options?: OptionsInterface<B>) => Promise<ResponseInterface<T, BodyFromSchema<B, OptionsInterface>>>, head: <T, B>(url?: string, options?: OptionsInterface<B>) => Promise<ResponseInterface<T, BodyFromSchema<B, OptionsInterface>>>, options: <T, B>(url?: string, options?: OptionsInterface<B>) => Promise<ResponseInterface<T, BodyFromSchema<B, OptionsInterface>>>, connect: <T, B>(url?: string, options?: OptionsInterface<B>) => Promise<ResponseInterface<T, BodyFromSchema<B, OptionsInterface>>>, trace: <T, B>(url?: string, options?: OptionsInterface<B>) => Promise<ResponseInterface<T, BodyFromSchema<B, OptionsInterface>>>, extend: <T, B>(extendOptions: OptionsInterface<B>) => Promise<{
    request: <T_1, B_1>(options?: OptionsInterface<B_1>, currentRedirects?: number, attempt?: number, visitedUrls?: Set<string>) => Promise<ResponseInterface<T_1, BodyFromSchema<B_1, OptionsInterface>>>;
    get: <T_1, B_2>(url?: string, options?: OptionsInterface<B_2>) => Promise<ResponseInterface<T_1, BodyFromSchema<B_2, OptionsInterface>>>;
    post: <T_1, B_3>(url?: string, options?: OptionsInterface<B_3>) => Promise<ResponseInterface<T_1, BodyFromSchema<B_3, OptionsInterface>>>;
    put: <T_1, B_4>(url?: string, options?: OptionsInterface<B_4>) => Promise<ResponseInterface<T_1, BodyFromSchema<B_4, OptionsInterface>>>;
    delete: <T_1, B_5>(url?: string, options?: OptionsInterface<B_5>) => Promise<ResponseInterface<T_1, BodyFromSchema<B_5, OptionsInterface>>>;
    head: <T_1, B_6>(url?: string, options?: OptionsInterface<B_6>) => Promise<ResponseInterface<T_1, BodyFromSchema<B_6, OptionsInterface>>>;
    options: <T_1, B_7>(url?: string, options?: OptionsInterface<B_7>) => Promise<ResponseInterface<T_1, BodyFromSchema<B_7, OptionsInterface>>>;
    trace: <T_1, B_8>(url?: string, options?: OptionsInterface<B_8>) => Promise<ResponseInterface<T_1, BodyFromSchema<B_8, OptionsInterface>>>;
    connect: <T_1, B_9>(url?: string, options?: OptionsInterface<B_9>) => Promise<ResponseInterface<T_1, BodyFromSchema<B_9, OptionsInterface>>>;
    patch: <T_1, B_10>(url?: string, options?: OptionsInterface<B_10>) => Promise<ResponseInterface<T_1, BodyFromSchema<B_10, OptionsInterface>>>;
    [EventEmitter.captureRejectionSymbol]?: (<K>(error: Error, event: string | symbol, ...args: any[]) => void) | undefined;
    baseRequestOptions: OptionsInterface;
    pluginManager: PluginManager;
    use: (plugin: PluginInterface) => void;
    on: <K extends keyof Events>(event: K, listener: Events[K]) => NyroClass;
    once: <K extends keyof Events>(event: K, listener: Events[K]) => NyroClass;
    off: <K extends keyof Events>(event: K, listener: Events[K]) => NyroClass;
    emit: <K extends keyof Events>(event: K, ...args: Parameters<Events[K]>) => boolean;
    setURL: (url: string) => NyroClass;
    setBaseURL: (baseURL: string) => NyroClass;
    setPath: (path: string) => NyroClass;
    setBodySchema: (bodySchema: any) => NyroClass;
    setAuth: (auth: AuthOptions) => NyroClass;
    setProxy: (proxy: ProxyOptions) => NyroClass;
    setMethod: (method: "GET" | "POST" | "PUT" | "DELETE" | "PATCH" | "HEAD" | "OPTIONS" | "CONNECT" | "TRACE") => NyroClass;
    setHeaders: (headers: (HeadersInterface & Record<string, string>)) => NyroClass;
    setParams: (params: Record<string, string>) => NyroClass;
    setQuery: (query: Record<string, string | number | boolean>) => NyroClass;
    setBody: (body: any) => NyroClass;
    setTimeout: (timeout: number) => NyroClass;
    setRetryOn: (retryOn: (req: import("http").RequestOptions, error: Error) => boolean) => NyroClass;
    setRetries: (retries: number) => NyroClass;
    setValidateStatus: (validateStatus: (status: number) => boolean) => NyroClass;
    setMaxBodyLength: (maxBodyLength: number) => NyroClass;
    setMaxContentLength: (maxContentLength: number) => NyroClass;
    setMaxRate: (maxRate: number) => NyroClass;
    setSignal: (signal: AbortSignal) => NyroClass;
    setOnDownloadProgress: (onDownloadProgress: (progress: {
        percent: number;
        transferredBytes: number;
        totalBytes: number;
    }) => void) => NyroClass;
    setTimeoutErrorMessage: (timeoutErrorMessage: string) => NyroClass;
    setResponseType: (responseType: ("json" | "text" | "blob" | "stream" | "arrayBuffer" | ("document" & string))) => NyroClass;
    setResponseEncoding: (responseEncoding: BufferEncoding) => NyroClass;
    setMaxRedirects: (maxRedirects: number) => NyroClass;
    setRetryDelay: (retryDelay: number) => NyroClass;
    setDecompress: (decompress: boolean) => NyroClass;
    download: <T_1, B_11>(url?: string, options?: OptionsInterface<B_11>) => Promise<ResponseInterface<T_1, BodyFromSchema<B_11, OptionsInterface>>>;
    pagination: <T_1, B_12>(options?: OptionsInterface<B_12>, paginationOptions?: PaginationOptions) => Promise<Array<ResponseInterface<T_1, BodyFromSchema<B_12, OptionsInterface>>>>;
    queue: <T_1, B_13>(requests: Array<OptionsInterface<B_13>>, queueOptions?: QueueOptions) => Promise<Array<ResponseInterface<T_1, BodyFromSchema<B_13, OptionsInterface>>>>;
    extend: any;
    addListener: <K>(eventName: string | symbol, listener: (...args: any[]) => void) => NyroClass;
    removeListener: <K>(eventName: string | symbol, listener: (...args: any[]) => void) => NyroClass;
    removeAllListeners: (eventName?: string | symbol | undefined) => NyroClass;
    setMaxListeners: (n: number) => NyroClass;
    getMaxListeners: () => number;
    listeners: <K>(eventName: string | symbol) => Function[];
    rawListeners: <K>(eventName: string | symbol) => Function[];
    listenerCount: <K>(eventName: string | symbol, listener?: Function | undefined) => number;
    prependListener: <K>(eventName: string | symbol, listener: (...args: any[]) => void) => NyroClass;
    prependOnceListener: <K>(eventName: string | symbol, listener: (...args: any[]) => void) => NyroClass;
    eventNames: () => (string | symbol)[];
}>, request: <T, B>(options?: OptionsInterface<B>, currentRedirects?: number, attempt?: number, visitedUrls?: Set<string>) => Promise<ResponseInterface<T, BodyFromSchema<B, OptionsInterface>>>;
/**
* @description The main Nyro function.
*
* This function is the main entry point for the Nyro module. It is a wrapper around the request function and can be used to make HTTP requests.
* @async
* @function nyro
* @param {OptionsInterface} options - The options for the request.
* @returns {Promise<ResponseInterface>} A promise that resolves to the response object.
* @example nyro({ url: 'https://jsonplaceholder.typicode.com/posts/1', method: 'GET' }).then(console.log);
* @example nyro.get('https://jsonplaceholder.typicode.com/posts/1').then(res => res.json()).then(console.log);
* @example nyro.post('https://jsonplaceholder.typicode.com/posts', { body: { title: 'foo', body: 'bar', userId: 1 } }).then(console.log);
*/
declare const nyro: (<T, B>(options: OptionsInterface<B>) => Promise<ResponseInterface<any, B extends NumberConstructor ? number : B extends StringConstructor ? string : B extends Record<string, unknown> ? { [K in keyof B]: B[K] extends NumberConstructor ? number : B[K] extends StringConstructor ? string : B[K] extends ArrayConstructor ? any[] : B[K]; } : B extends ArrayConstructor ? any[] : B>>) & NyroClass;
type NyroType = typeof nyro;
export default nyro;
import { ContentType, StatusCode, Method, ResponseEncoding, ResponseType } from './helpers/types';
export { Nyro, NyroType, request, extend, get, post, put, patch, _delete as delete, head, options, connect, trace, RequestInfo, Options, OptionsInterface, ResponseInterface, Headers, HeadersInterface, InferBodySchema, BodyFromSchema, version, NyroError, NyroErrorInterface, NyroErrorResponse, isNyroError, Proxy, Protocol, ProxyAPIOptions, ProxyAPIResponse, ProxyObject, ProxyFetchOptions, ProxyFormat, ProxyFilterOptions, OmitedProxyAPIResponse, Anonymity, Country, Format, UserAgent, AndroidVersions, ChromeVersions, SafariVersions, UserAgentBrowser, UserAgentDevice, UserAgentOS, GenerateUserAgentOptions, generateAndroid, generateChrome, generateEdge, generateFirefox, generateSafari, getRandomVersion, PluginManager as Plugin, PluginInterface, ContentType, StatusCode, Method, ResponseEncoding, ResponseType, Events, QueueOptions, PaginationOptions, AuthOptions, ProxyOptions };
